# -*- coding: utf-8 -*-
"""sentiment_analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jea_cV2LAsoJGSZ1rVsqcBZA1sEpWvLQ
"""

'''
 {
  "chatId": "",
  "messages": [
    {
      "id": "",
      "content": "",
      "user": {"name": ""},
      "createdAt": ""
      "sentiment": {"emo1": 'float', ..., "emo5": 'float'}
    },
    {
      "id": "",
      "content": "",
      "user": {"name": ""},
      "createdAt": ""
      "sentiment": {"emo1": 'float', ..., "emo5": 'float'}
    },
    {
      "id": "",
      "content": "",
      "user": {"name": ""},
      "createdAt": ""
      "sentiment": {"emo1": 'float', ..., "emo5": 'float'}
    }
  ],
  "timestamp": ""
}
'''

hist1={
  "chatId": "general",
  "messages": [
    {
      "id": "27b7b66f-33bd-4a49-95e1-78e4bbadc7ea",
      "content": "Yo",
      "user": {
        "name": "god"
      },
      "sentiment": {"sadness": 1, "joy": 0, "love": 0, "anger": 0, "fear": 0, "surprise": 0},
      "createdAt": "2025-06-07T11:28:57.676Z"
    }
  ],
  "timestamp": "2025-06-07T11:29:18.624Z"
}

hist2={
  "chatId": "general",
  "messages": [
    {
      "id": "353fc390-3afe-49a4-a88a-64a32aed0c85",
      "content": "What's going on?",
      "user": {
        "name": "test"
      },
      "sentiment": {"sadness": 0, "joy": 1, "love": 0, "anger": 0, "fear": 0, "surprise": 0},
      "createdAt": "2025-06-07T11:29:07.095Z"
    }
  ],
  "timestamp": "2025-06-07T11:29:18.624Z"
}

hist3={
  "chatId": "general",
  "messages": [
    {
      "content": "Nothing much",
      "createdAt": "2025-06-07T11:29:16.624Z",
      "id": "87b12e2b-6b8f-4562-ad65-487280d8e0aa",
      "user": {"name": "god"},
      "sentiment": {"sadness": 0, "joy": 0, "love": 1, "anger": 0, "fear": 0, "surprise": 0},
    }
  ],
  "timestamp": "2025-06-07T11:29:18.624Z"
}

def truncated_multivariate_normal(mean, cov, lower, upper):
    d = len(mean)
    while(True):
        x = np.random.multivariate_normal(mean, cov)
        if np.all(x >= lower) and np.all(x <= upper):
            return x

import numpy as np
from itertools import groupby
from collections import defaultdict
import os
import pickle as pkl

def sentiment_analytics(chat_hist, buffers):

    emo2id = {
        'sadness': 0,
        'joy': 1,
        'love': 2,
        'anger': 3,
        'fear': 4,
        'surprise': 5
    }
    emo_high = {
        'sadness': 0.16,
        'joy': 0.16,
        'love': 0.16,
        'anger': 0.16,
        'fear': 0.16,
        'surprise': 0.16
    }
    emo_low = {
        'sadness': 0.12,
        'joy': 0.12,
        'love': 0.12,
        'anger': 0.12,
        'fear': 0.12,
        'surprise': 0.12
    }

    last_msg = chat_hist['messages'][-1]
    last_usr = last_msg['user']['name']
    new_emo = np.zeros(len(emo2id))
    for key, val in last_msg['sentiment'].items():
        # val = np.random.rand(1,) * (emo_high[key] - emo_low[key]) + emo_low[key]
        new_emo[emo2id[key]] = val
    # emo = last_msg['sentiment']
    # new_emo[emo2id[emo]] = 1

    new_emo /= np.sum(new_emo)

    # DEBUG
    print(f"New Emotion Var: {new_emo}")
    
    if os.path.exists("user_dist.pkl"):
        with open('user_dist.pkl', 'rb') as f:
            user_emo_dist = pkl.load(f)
    else:
        user_emo_dist = {last_usr: {'count': 0,
                                    'mu': np.zeros(len(emo2id),),
                                    'cov': np.zeros(len(emo2id)),
                                    'hist': []},
                         '__GrOuP__': {'count': 0,
                                    'mu': np.zeros(len(emo2id),),
                                    'cov': np.zeros(len(emo2id)),
                                    'hist': []}}

    if last_usr not in user_emo_dist.keys():
        user_emo_dist.update({last_usr: {'count': 0,
                                         'mu': np.zeros(len(emo2id),),
                                         'cov': np.zeros(len(emo2id)),
                                         'hist': []}})

    count = user_emo_dist[last_usr]["count"]
    mu = user_emo_dist[last_usr]["mu"]
    cov = user_emo_dist[last_usr]["cov"]

    count += 1
    delta = new_emo - mu
    mu_new = mu + (delta / count)
    delta2 = new_emo - mu_new
    cov_new = (cov * (count-1) + np.outer(delta, delta2)) / count

    user_emo_dist[last_usr]["count"] = count
    user_emo_dist[last_usr]["mu"] = mu_new
    user_emo_dist[last_usr]["cov"] = cov_new
    
    var = np.diag(cov_new)
    std_dev = np.sqrt(var)
    with np.errstate(divide='ignore', invalid='ignore'):
        user_emo_dist[last_usr]['coeffvar'] = np.where(mu_new != 0, std_dev / mu_new, np.nan)
    user_emo_dist[last_usr]["hist"].append(new_emo)
    if len(user_emo_dist[last_usr]["hist"]) > max(buffers):
        user_emo_dist[last_usr]["hist"].pop(0)

    for buffer in buffers:
        user_emo_dist[last_usr]['mu_{}'.format(buffer)] = np.mean(user_emo_dist[last_usr]["hist"][-buffer:], axis=0)

        if len(user_emo_dist[last_usr]["hist"]) == 1:
            user_emo_dist[last_usr]['cov_{}'.format(buffer)] = np.zeros(cov_new.shape)
        else:
            user_emo_dist[last_usr]['cov_{}'.format(buffer)] = np.cov(user_emo_dist[last_usr]["hist"][-buffer:], rowvar=False)

        var = np.diag(user_emo_dist[last_usr]['cov_{}'.format(buffer)])
        std_dev = np.sqrt(var)
        mean = user_emo_dist[last_usr]['mu_{}'.format(buffer)]
        with np.errstate(divide='ignore', invalid='ignore'):
          user_emo_dist[last_usr]['coeffvar_{}'.format(buffer)] = np.where(mean != 0, std_dev / mean, np.nan)

    if np.mean(user_emo_dist[last_usr]['coeffvar_{}'.format(max(buffers))]) > 0.75 and len(user_emo_dist[last_usr]['hist']) == max(buffers):
        user_emo_dist[last_usr]['volatile'] = 1
    else:
        user_emo_dist[last_usr]['volatile'] = 0

    user_emo_dist['__GrOuP__']['mu'] = np.mean([v['mu'] for k, v in user_emo_dist.items() if k!='__GrOuP__'], axis=0)

    for buffer in buffers:
        user_emo_dist['__GrOuP__']['mu_{}'.format(buffer)] = np.mean([v['mu_{}'.format(buffer)] for k, v in user_emo_dist.items() if k!='__GrOuP__'], axis=0)
        user_emo_dist['__GrOuP__']['cov_{}'.format(buffer)] = None
        user_emo_dist['__GrOuP__']['coeffvar_{}'.format(buffer)] = None

    user_emo_dist['__GrOuP__']['cov'] = None
    user_emo_dist['__GrOuP__']['coeffvar'] = None
    user_emo_dist['__GrOuP__']['hist'] = None
    user_emo_dist['__GrOuP__']['volatile'] = None

    with open('user_dist.pkl', 'wb') as f:
        pkl.dump(user_emo_dist, f)

    return user_emo_dist

id2emo = {
    0: 'sadness',
    1: 'joy',
    2: 'love',
    3: 'anger',
    4: 'fear',
    5: 'surprise'
}

user_emo_dist = sentiment_analytics(hist1, [10])
user_emo_dist = sentiment_analytics(hist2, [10])
user_emo_dist = sentiment_analytics(hist3, [10])

for user, values in user_emo_dist.items():
    print(user, ' mu: ', values['mu'])
    # print(user, ' cov: ', values['cov'])
    print(user, ' coeffvar: ', values['coeffvar'])
    print(user, ' mu_10: ', values['mu_10'])
    print(user, ' coeffvar_10: ', values['coeffvar_10'])
    print(user, ' volatile: ', values['volatile'])
    # print(user, ': ', values['cov_10'])
    print(user, ' hist: ', (values['hist']))

# NOTES:
# user = '__GrOuP__' provides group statistics
# for trend: plot the hist (size = max(buffers)) OR track last 'n' values['mu']
# for session trend: keep appending values['mu'] to the plot
# use below code as reference for accessing instances of sentiment
'''
sentiment = {}
for probs in values['mu']:
    sentiment[id2emo[id]] = prob
print(sentiment)
sentiment = {}
for probs in values['hist']:
    for id, prob in enumerate(probs):
        sentiment[id2emo[id]] = prob
print(sentiment)
'''